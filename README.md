# Unreal Practice

## 3강 언리얼 C++ 기본 타입과 문자열 처리

1. 언리얼이 C++ 타입 int를 사용하지 않는 이유
2. 다양한 캐릭터 인코딩 시스템의 이해
3. 언리얼의 문자열 처리의 이해
4. FString의 구조와 사용 방법
5. FName의 구조와 사용 방법

## 4강 언리얼 오브젝트 기초

- 클래스 기본 객체(CDO): 클래스의 기본 값과 타입 정보의 제공
- 리플렉션(Reflection): 런타임에서 클래스 정보의 참조 기능
- 인터페이스(Interface): 모던 객체 지향 언어가 제공하는 인터페이스의 제공
- 향상된 열거형: 보다 향상된 열거형의 지원
- 델리케이트(Deligate): 객체간의 결합을 낮출 수 있는 델리케이트 기능의 제공
- 가비지컬렉션(Garbage Collection): 자동 메모리 관리
- 향상된 구조체(Struct): 리플렉션이 가능한 구조체의 지원
- 직렬화(Serialization): 객체 정보를 바이트 스트림으로 저장, 전송, 불러들이는 기능

### 정리

- 게임이 대형화되면서 성능과 유지보수 두 가지가 모두 중요해짐.
- 언리얼 엔진은 C++ 언어를 확장한 언리얼 오브젝트라는 객체 구조를 고안함.
- 지정된 매크로를 사용해 빌드를 수행하면, 추가 코드가 자동으로 만들어지는 구조를 가짐.
- 언리얼 오브젝트를 사용해 대규모 게임 제작을 안정적으로 설계하고 구현할 수 있음.

## 5강 언리얼 오브젝트 리플렉션 시스템1

리플렉션은 프로그램이 실행시간에 자기 자신을 조사하는 기능.

언리얼 자체적으로 구축함.

### 언리얼 오브젝트의 구성

- 언리얼 오브젝트에는 특별한 프로퍼티와 함수를 지정할 수 있음.
  - 관리되는 클래스 맴버 변수: UPROPERTY
  - 관리되는 클래스 맴버 함수: UFUNCTION
  - 에디터와 연동되는 메타데이터를 심을 수 있음
- 모든 언리얼 오브젝트는 클래스 정보와 함께 함.
  - 클래스를 사용해 자신이 가진 프로퍼티와 함수 정보를 컴파일 타임과 런타임에서 조회할 수 있음.
- 이렇게 다양한 기능을 제공하는 언리얼 오브젝트는 NewObjectAPI를 사용해 생성해야 함.

### 언리얼 오브젝트의 클래스 기본 오브젝트

- 언리얼 클래스 정보에는 클래스 기본 오브젝트가 함께 포함되어 있음.
- 클래스 기본 오브젝트는 줄여서 CDO라고 부름.
- CDO는 언리얼 객체가 가진 기본 값을 보관하는 템플릿 객체임.
- 한 클래스로부터 다수의 물체를 생성해 게임 콘텐츠에 배치할 때 일관성 있게 기본 값을 조정하는데 유용하게 사용됨.
- CDO는 클래스 정보로부터 GetDefaultObject() 함수를 통해 얻을 수 있음.
- UClass 및 CDO는 엔진 초기화 과정에서 생성되므로 콘텐츠 제작에서 안심하고 사용할 수 있음.

### 정리

- 언리얼 오브젝트에는 항상 클래스 정보를 담은 UClass 객체가 매칭되어 있다.
- UClass로부터 언리얼 오브젝트의 정보를 파악할 수 있음
- UClass에는 클래스 기본 오브젝트(CDO)가 연결되어 있어 이를 활용해 개발의 생산성을 향상시킬 수 있음.
- 클래스 정보와 CDO는 엔진 초기화 과정에서 생성되므로 게임 개발에서 안전하게 사용 가능.
- 헤더 정보를 변경하거나 생성자 정보를 변경하면 에디터를 끄고 컴파일하는 것이 안정적임.

## 6강 언리얼 오브젝트 리플렉션 시스템2

### 언리얼 리플렉션 시스템의 활용

- 리플렉션 시스템을 사용해 언리얼 오브젝트의 속성과 함수를 이름으로 검색할 수 있다.
- 리플렉션 시스템을 사용해 접근 지시자와 무관하게 값을 설정할 수 있다.
- 리플렉션 시스템을 사용해 언리얼 오브젝트의 함수를 호출할 수 있다.

## 7강 언리얼 C++ 설계1 - 인터페이스

### 인터페이스란?

- 객체가 반드시 구현해야 할 행동을 지정하는데 활용되는 타입
- 다형성의 구현, 의존성이 분리된 설계에 유용하게 활용.

### 언리얼 엔진에서 게임 콘텐츠를 구성하는 오브젝트의 설계 예시

- 월드에 배치되는 모든 오브젝트, 안 움직이는 오브젝트를 포함 (Actor)
- 움직이는 오브젝트 (Pawn)
- 길찾기 시스템을 반드시 사용하면서 움직이는 오브젝트
- (INavAgentInterface 인터페이스를 구현한 Pawn)

### 언리얼 C++ 인터페이스 특징

- 인터페이스를 생성하면 두 개의 클래스가 생성됨
  - U로 시작하는 타입 클래스
  - I로 시작하는 인터페이스 클래스
- 객체를 설계할 때 I 인터페이스 클래스를 사용
  - U타입 클래스 정보는 런타임에서 인터페이스 구현 여부를 파악하는 용도로 사용됨.
  - 실제로 U타입 클래스에서 작업할 일은 없음.
  - 인터페이스에 관련된 구성 및 구현은 I 인터페이스 클래스에서 진행
- C++ 인터페이스의 특징
  - 추상 타입으로만 선언할 수 있는 JAVA, C#과 달리 언리얼은 인터페이스에도 구현이 가능함.

### 정리

- 클래스가 반드시 구현해야 하는 기능을 지정하는데 사용함.
- C++은 기본적으로 다중상속을 지원하지만, 언리얼 C++의 인터페이스를 사용해 가급적 축소된 다중상속의 형태로 구현하는 것이 향후 유지보수에 도움된다.
- 언리얼 C++ 인터페이스는 두 개의 클래스를 생성한다.
- 언리얼 C++ 인터페이스는 추상 타입으로 강제되지 않고, 내부에 기본 함수를 구현할 수 있다.

## 8강 언리얼 C++ 설계2 - 컴포지션

### 컴포지션

- 객체 지향 설계에서 상속이 가진 Is-A관계만 의존해서는 설계와 유지보수가 어려움.
- 컴포지션은 객체 지향 설계에서 Has-A관계를 구현하는 설계 방법
- 컴포지션의 활용
  - 복합적인 기능을 거대한 클래스를 효과적으로 설계하는데 유용하게 사용할 수 있음

### 언리얼 엔지에서의 컴포지션 구현 방법

- 하나의 언리얼 오브젝트에는 항상 클래스 기본 오브젝트 CDO가 있다.
- 언리얼 오브젝트간의 컴포지션은 어떻게 구현할 것인가?
- 언리얼 오브젝트에 다른 언리얼 오브젝트를 조합할 때의 다음의 선택지가 존재한다.
  - 방법 1: CDO에 미리 언리얼 오브젝트를 생성해 조합한다. (필수적 포함)
  - 방법 2: CDO에 빈 포인터만 넣고 런타임에서 언리얼 오브젝트를 생성해 조합한다. (선택적 포함)
- 언리얼 오브젝트를 생성할 때 컴포지션 정보를 구축할 수 있다.
  - 내가 소유한 언리얼 오브젝트를 Subobject라고 한다.
  - 나를 소유한 언리얼 오브젝트를 Outer라고 한다.

### 정리

- 언리얼 C++은 컴포지션을 구현하는 독특한 패턴이 있다.
- 클래스 기본 객체를 생성하는 생성자 코드를 사용해 복잡한 언리얼 오브젝트를 생성할 수 있음.
- 언리얼 C++ 컴포지션의 Has-A관계에 사용되는 용어
  - 내가 소유한 하위 오브젝트 Subobject
  - 나를 소유한 상위 오브젝트: Outer
- 언리얼 C++이 제공하는 확장 열거형을 사용해 다양한 메타 정보를 넣고 활용할 수 있다.

## 9강 언리얼 C++ 설계3 - 델리게이트

### 강한 결합과 느슨한 결합

- 강한 결합
  - 클래스들이 서로 의존성을 가지는 경우를 의미한다.
  - 아래 예시에서 Card가 없는 경우 Person이 만들어질 수 없다.
  - 이때 Person은 Card에 대한 의존성을 가진다고 한다.
  - 핸드폰에서도 인증할 수 있는 새로운 카드가 도입된다면
- 느슨한 결홥
  - 실물에 의존하지 말고 추상적 설계에 의존하라.(DIP 원칙)
  - 왜 Person은 Card가 필요한가? 출입을 확인해야 하기 떄문
  - 출입에 관련된 추상적인 설계에 의존하자.
  - ICheck를 상속받은 새로운 카드 인터페이스를 선언해 해결
  - 이러한 느슨한 결합 구조는 유지 보수를 손쉽게 만들어줌.

### 느슨한 결합의 간편한 구현 - 델리게이트

- 함수를 다루는 방법
  - 함수 포인터를 활용한 콜백함수의 구현
  - 기능은 하나 이를 정의하고 사용하는 과정이 꽤나 복잡함.
  - 안정성을 스스로 검증해주어야 함.
  - C++ 17규약의 std::bind와 std::function 활용은 느림
- C#의 델리게이트 키워드
  - 함수를 마치 객체처럼 다룰 수 있음
  - 안정적이고 간편한 선언
- 언리얼 C++도 델리게이트 지원
  - 느슨한 결합 구조를 간편하고 안정적으로 구현할 수 있음.

### 발행 구독 디자인 패턴

- 푸시 형태의 알림을 구현하는데 적합한 디자인 패턴
- 발행자와 구독자로 구분된다
  - 콘텐츠 제작자는 콘텐츠를 생산한다.
  - 발행자는 콘텐츠를 배포한다.
  - 구독자는 배포된 콘텐츠를 받아 소비한다.
  - 제작자와 구독자가 서로를 몰라도, 발행자를 통해 콘텐츠를 생산하고 전달할 수 있다. (느슨한 결합)
- 발행 구독 디자인 패턴의 장점
  - 제작자와 구독자는 서로를 모르기 떄문에 느슨한 결합으로 구성된다.
  - 유지 보수가 쉽고, 유연하게 활용될 수 있으며, 테스트가 쉬워진다.
  - 시스템 스케일을 유연하게 조절할 수 있으며, 기능 확장이 용이하다.

### 언리얼 델리케이트 선언시 고려사항

- 델리게이트를 설계하기 위한 고려사항

  - 어떤 데이터를 전달하고 받을 것인가? 인자의 수와 각각의 타입을 설계
    - 몇 개의 인자를 전달할 것인가?
    - 어떤 방식으로 전달할 것인가?
    - 일대일로 전달
    - 일대다로 전달
  - 프로그래밍 환경 설정
    - C++ 프로그래밍에서만 사용할 것인가?
    - UFUNCTION으로 지정된 블루프린트 함수와 사용할 것인가?
  - 어떤 함수와 연결할 것인가?
    - 클래스 외부에 설계된 C++ 함수와 연결
    - 전역에 설계된 정적 함수와 연결
    - 언리얼 오브젝트의 맴버 함수와 연결 ( 대부분의 경우에 이 방식을 사용 )

### 언리얼 델리게이트 선언 매크로

**DECLARE\_{델리케이트유형}DELEGATE{함수정보}**

- 델리게이트 유형: 어떤 유형의 델리게이트인지 구상한다
  - 일대일 형태로 C++만 지원한다면 유형은 공란으로 둔다.</br>
    **DECLARE_DELEGATE**
  - 일대다 형태로 C++만 지원한다면 MULTICAST를 선언한다.</br>
    **DECLARE_MULTICAST**
  - 일대일 형태로 블루프린트를 지원한다면 DYNAMIC을 선언한다.</br>
    **DECLARE_DYNAMIC**
  - 일대다 형태로 블루프린트를 지원한다면 DYNAMIC과 MULTICAST를 조합한다.</br>
    **DECLARE_DYNAMIC_MULTICAST**
- 함수 정보 : 연동 될 함수 형태를 지정한다.
  - 인자가 없고 반환값도 없으면 공란으로 둔다.
  - 인자가 하나고 반환값이 없으면 OneParam으로 지정한다.
  - 인자가 세 개고 반환값이 있으면 RetVal_ThreeParams로 지정한다.
  - 최대 9개까지 지원함

### 정리

- 느슨한 결합이 가지는 장점
  - 향후 시스템 변경 사항에 대해 손쉽게 대처할 수 있음
- 느슨한 결합으로 구현된 발행 구독 모델의 장점
  - 클래스는 자신이 해야 할 작업에만 집중할 수 있음.
  - 외부에서 발생한 변경 사항에 대해 영향받지 않음.
  - 자신의 기능을 확장하더라도 다른 모듈에 영향을 주지 않음.
- 언리얼 C++의 델리게이트의 선언 방법과 활용
  - 몇 개의 인자를 가지는가?
  - 어떤 방식으로 동작하는가?
  - 언리얼 에디터와 함께 연동할 것인가?
  - 이를 조합해 적합한 매크로 선택

## 10강 언리얼 컨테이너 라이브러리1 - Array와 Set

### 언리얼 컨테이너 라이브러리

- 언리얼 엔진이 자체 제작해 제공하는 자료구조 라이브러리
- 언리얼 오브젝트를 안정적으로 지원하면 다수 오브젝트 처리에 유용하게 사용됨.
- 언리얼 C++은 다양한 자료구조 라이브러리를 직접 만들어 제공하고 있음.

### C++ STL과 언리얼 컨테이너 라이브러리의 차이점

- C++ STL은 범용적으로 설계되어 있다.
- C++ STL은 표준이기 때문에 호환성이 높다.
- C++ STL에는 많은 기능이 엮여 있어 컴파일 시간이 오래 걸림.
- 언리얼 컨테이너 라이브러리는 언리얼 엔진에 특화되어 있음.
- 언리얼 컨테이너 라이브러리는 언리얼 오브젝트 구조를 안정적으로 지원한다.
- 언리얼 컨테이너 라이브러리는 가볍고 게임 제작에 최적화되어 있음.

### TArray 개요

- TArray는 가변 배열 자료구조
- STL의 vector와 동작 원리가 유사함.
- 게임 제작에서는 가변 배열 자료구조를 효과적으로 활용하는 것이 좋음.
  - 데이터가 순차적으로 모여있기 때문에 메모리를 효과적으로 사용할 수 있고 캐시 효율이 높다.
  - 컴퓨터 사양이 좋아지면서, 캐시 지역성으로 인한 성능 향상은 괴장히 중요해짐.
  - 임의 데이터의 접근이 빠르고, 고속으로 요소를 순회하는 것이 가능.
- 가변 배열의 단점
  - 맨 끝에 데이터를 추가하는 것은 가볍지만, 중간에 요소를 추가하거나 삭제하는 작업은 비용이 큼
  - 데이터가 많아질 수록 검색, 삭제, 수정 작업이 느려지기 때문에, 많은 수의 데이터에서 검색 작업이 빈번하게 일어난다면 TArray대신 TSet을 사용하는 것이 좋음.

### TSet의 특징

- STL의 set과 언리얼 TSet의 비교
  - STL set의 특징
    - STL set은 이진 트리로 구성되어 있어 정렬을 지원함.
    - STL set은 메모리 구성이 효율적이지 않음.
    - STL set은 요소가 삭제될 때 균형을 위한 재구축이 일어날 수 있음.
    - STL set의 모든 자료를 순회하는데 적합하지 않음.
  - 언리얼 TSet 특징
    - TSet은 해시테이블 형태로 키 데이터가 구축되어 있어 빠른 검색이 가능함.
    - TSet은 동적 배열의 형태로 데이터가 모여있음.
    - TSet의 데이터는 빠르게 순회할 수 있음.
    - TSet의 데이터는 삭제해도 재구축이 일어나지 않음.
    - TSet의 자료에는 비어있는 데이터가 있을 수 있음.
- 따라서 STL set과 언리얼 TSet의 활용 방법은 서로 다르기 때문에 주의할 것.
- STL의 unordered_set과 유사하게 동작하지만 동일하진 않음.
- TSet은 중복 없는 데이터 집합을 구축하는데 유용하게 사용할 수 있음.

### 정리

- TArray, TSet 컨테이너 라이브러리 내부 구조와 활용 방법
- 디버그 빌드를 사용해 메모리 정보를 확인하는 방법의 학습
- 두 컨테이너 라이브러리가 가진 특징의 이해

## 11강 언리얼 컨테이너 라이브러리2 - 구조체와 Map

### 언리얼 구조체 UStruct

- 데이터 저장/전송에 특화된 가벼운 객체
- 대부분 GENERATED_BODY 매크로롤 선언해준다.
  - 리플렉션, 직렬화와 같은 유용한 기능을 지원함.
  - GENERATED_BODY를 선언한 구조체는 UScriptStruct 클래스로 구현됨.
  - 이 경우 제한적으로 리플렉션을 지원함.
    - 속성 UPROPERTY만 선언할 수 있고 함수 UFUNCTION은 선언할 수 없음
- 언리얼 엔진의 구조체 이름은 F로 시작함.
  - 대부분 힙 메모리 할당없이 스태 내 데이터로 사용됨.
  - NewObjectAPI를 사용할 수 없음.

### TMap의 특징

- STL map과 TMap의 비교
  - STL map의 특징
    - STL map은 STL set과 동일하게 이진 트리로 구성되어 있음.
    - 정렬은 지원하지만, 메모리 구성이 효율적이지 않으며, 데이터 삭제시 재구축이 일어날 수 있음.
    - 모든 자료를 순회하는데 적합하진 않음.
  - 언리얼 TMap의 특징
    - 키, 밸류 구성의 튜플 데이터의 TSet구조로 구현되어 있음
    - 해시테이블 형태로 구축되어 있어 빠른 검색이 가능함.
    - 동적 배열의 형태로 데이터가 모여있음.
    - 데이터는 빠르게 순회할 수 있음.
    - 데이터는 삭제해도 재구축이 일어나지 않음.
    - 비어있는 데이터가 있을 수 있음.
    - TMultiMap을 사용하면 중복 데이터를 관리할 수 있음
- 동작 원리는 STL unordered_map과 유사함.
- 키, 밸류 쌍이 필요한 자료구조에 광범위하게 사용됨.

### 정리

- TArray, TSet, TMap 컨테이너 라이브러리 내부 구조와 활용 방법
- 언리얼 구조체의 선언 방법
- TSet과 TMap에서 언리얼 구조체를 사용하기 위해 필요한 함수의 선언과 구현 방법

## 12강 언리얼 엔진의 메모리 관리

### C++언어 메모리 관리의 문제점

- C++은 저수준으로 메모리 주소에 직접 접근하는 포인터를 사용해 오브젝트를 관리한다.
- 그러다보니 프로그래머가 직접 할당과 해지 짝 맞추기를 해야한다.
- 잘못된 포인터 사용 예시
  - 메모리 누수: new를 했는데 delete 짝을 맞추지 못함. 힙에 메모리가 그대로 남아있음.
  - 허상 포인터: 이미 해제해 무효화된 오브젝트의 주소를 가리키는 포인터
  - 와일드 포인터: 값이 초기화되지 않아 엉뚱한 주소를 가리키는 포인터
- 잘못된 포인터 값은 다양한 문제를 일으키며, 한 번의 실수는 프로그램을 종료시킴.
- 게임 규모가 커지고 구조가 복잡해질수록 프로그래머가 실수할 확률은 크게 증가한다.

### 가비지 콜렉션 시스템

- 프로그램에서 더 이상 사용하지 않는 오브젝트를 자동으로 감지해 메모리를 회수하는 시스템.
- 동적으로 생성된 모든 오브젝트 정보를 모아둔 저장소를 사용해 사용되지 않는 메모리를 추적
- 마크-스웹 방식의 가비지 컬렌션
  1. 저장소에서 최초 검색을 시작하는 루트 오브젝트를 표기한다.
  2. 루트 오브젝트가 참조하는 객체를 찾아 마크한다.
  3. 마크된 객체로부터 다시 참조하는 객체를 찾아 마크하고 이를 반복한다.
  4. 이제 저장소에는 마크된 객체와 마크되지 않는 객체의 두 그룹으로 나뉜다.
  5. 가비지 컬렉터가 저장소에서 마크되지 않는 객체들의 메모리를 회주한다. (스윕)

### 언리얼 엔진의 가비지 컬렉션 시스템

- 마크-스윕 방식의 가비지 컬레션 시스템을 자체적으로 구축함.
- 지정된 주기마다 몰아서 없애도록 설정되어 있음. (GCCycle. 기본 값 60초)
- 성능 향상을 위해 병렬 처리, 클러스터링과 같은 기능을 탑재함.

### 가비지 컬렉션을 위한 객체 저장소

- 관리되는 모든 언리얼 오브젝트의 정보를 저장하는 전역 변수: GUObjectArray
- GUObjectArray의 각 요소에는 플래그가 설정되어 있음.
- 가비지 컬렉터가 참고하는 주요 플래그
  - Garbage 플래그: 다른 언리얼 오브젝트로부터의 참조가 없어 회수 예정인 오브젝트
  - RootSet 플래그: 다른 언리얼 오브젝트로부터 참조가 없어도 회수하지 않는 특별한 오브젝트

### 언리얼 오브젝트를 통한 포인터 문제의 해결

- 메모리 누수 문제
  - 언리얼 오브젝트는 가비지 컬렉터를 통해 자동으로 해결.
  - C++ 오브젝트는 직접 신경써야 함. (스마트 포인터 라이브러리 활용)
- 댕글링 포인터 문제
  - 언리얼 오브젝트는 이를 탐지하기 위한 함수를 제공함 ::IsValid()
  - C++ 오브젝트는 직접 신경써야 함. (스마트 포인터 라이브러리 활용)
- 와일드 포인터 문제
  - 언리얼 오브젝트에는 UPROPERTY 속성을 지정하면 자동으로 nullptr로 초기화 함.
  - C++ 오브젝트의 포인터는 직접 nullptr로 초기화 할 것 (또는 스마트 포인터 라이브러리 활용)

### 언리얼 오브젝트의 관리 원칙

- 생성된 언리얼 오브젝트를 유지하기 위해 래퍼런스 참조 방법을 설계할 것
  - 언리얼 오브젝트 내의 언리얼 오브젝트: UPROPERTY 사용
  - 일반 C++ 오브젝트 내의 언리얼 오브젝트: FGCObject의 상속 후 구현
- 생성된 언리얼 오브젝트는 강제로 지우려 하지 말 것
  - 참조를 끊는다는 생각으로 설계할 것
  - 가비지 컬렉터에게 회수를 재촉할 수는 있음 (ForceGarbageCollection 함수)
  - 콘텐츠 제작에서 Destroy함수를 사용할 수 있으나, 결국 내부 동작은 동일함. (가비지컬렉터에 위임)

### 정리

- C++ 언어의 고질적인 문제인 포인터 문제의 이해
- 이를 해결하기 위한 가비지 콜렉션의 동작 원리의 이해와 설정 방법
- 다양항 상황에서 언리얼 오브젝트를 생성하고 메모리에 유지하는 방법의 이해
- 언리얼 오브젝트 포인터를 선언하는 코딩 규직의 이해
