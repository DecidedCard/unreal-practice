# Unreal Practice

## 3강 언리얼 C++ 기본 타입과 문자열 처리

1. 언리얼이 C++ 타입 int를 사용하지 않는 이유
2. 다양한 캐릭터 인코딩 시스템의 이해
3. 언리얼의 문자열 처리의 이해
4. FString의 구조와 사용 방법
5. FName의 구조와 사용 방법

## 4강 언리얼 오브젝트 기초

- 클래스 기본 객체(CDO): 클래스의 기본 값과 타입 정보의 제공
- 리플렉션(Reflection): 런타임에서 클래스 정보의 참조 기능
- 인터페이스(Interface): 모던 객체 지향 언어가 제공하는 인터페이스의 제공
- 향상된 열거형: 보다 향상된 열거형의 지원
- 델리케이트(Deligate): 객체간의 결합을 낮출 수 있는 델리케이트 기능의 제공
- 가비지컬렉션(Garbage Collection): 자동 메모리 관리
- 향상된 구조체(Struct): 리플렉션이 가능한 구조체의 지원
- 직렬화(Serialization): 객체 정보를 바이트 스트림으로 저장, 전송, 불러들이는 기능

### 정리

- 게임이 대형화되면서 성능과 유지보수 두 가지가 모두 중요해짐.
- 언리얼 엔진은 C++ 언어를 확장한 언리얼 오브젝트라는 객체 구조를 고안함.
- 지정된 매크로를 사용해 빌드를 수행하면, 추가 코드가 자동으로 만들어지는 구조를 가짐.
- 언리얼 오브젝트를 사용해 대규모 게임 제작을 안정적으로 설계하고 구현할 수 있음.

## 5강 언리얼 오브젝트 리플렉션 시스템1

리플렉션은 프로그램이 실행시간에 자기 자신을 조사하는 기능.

언리얼 자체적으로 구축함.

### 언리얼 오브젝트의 구성

- 언리얼 오브젝트에는 특별한 프로퍼티와 함수를 지정할 수 있음.
  - 관리되는 클래스 맴버 변수: UPROPERTY
  - 관리되는 클래스 맴버 함수: UFUNCTION
  - 에디터와 연동되는 메타데이터를 심을 수 있음
- 모든 언리얼 오브젝트는 클래스 정보와 함께 함.
  - 클래스를 사용해 자신이 가진 프로퍼티와 함수 정보를 컴파일 타임과 런타임에서 조회할 수 있음.
- 이렇게 다양한 기능을 제공하는 언리얼 오브젝트는 NewObjectAPI를 사용해 생성해야 함.

### 언리얼 오브젝트의 클래스 기본 오브젝트

- 언리얼 클래스 정보에는 클래스 기본 오브젝트가 함께 포함되어 있음.
- 클래스 기본 오브젝트는 줄여서 CDO라고 부름.
- CDO는 언리얼 객체가 가진 기본 값을 보관하는 템플릿 객체임.
- 한 클래스로부터 다수의 물체를 생성해 게임 콘텐츠에 배치할 때 일관성 있게 기본 값을 조정하는데 유용하게 사용됨.
- CDO는 클래스 정보로부터 GetDefaultObject() 함수를 통해 얻을 수 있음.
- UClass 및 CDO는 엔진 초기화 과정에서 생성되므로 콘텐츠 제작에서 안심하고 사용할 수 있음.

### 정리

- 언리얼 오브젝트에는 항상 클래스 정보를 담은 UClass 객체가 매칭되어 있다.
- UClass로부터 언리얼 오브젝트의 정보를 파악할 수 있음
- UClass에는 클래스 기본 오브젝트(CDO)가 연결되어 있어 이를 활용해 개발의 생산성을 향상시킬 수 있음.
- 클래스 정보와 CDO는 엔진 초기화 과정에서 생성되므로 게임 개발에서 안전하게 사용 가능.
- 헤더 정보를 변경하거나 생성자 정보를 변경하면 에디터를 끄고 컴파일하는 것이 안정적임.

## 6강 언리얼 오브젝트 리플렉션 시스템2

### 언리얼 리플렉션 시스템의 활용

- 리플렉션 시스템을 사용해 언리얼 오브젝트의 속성과 함수를 이름으로 검색할 수 있다.
- 리플렉션 시스템을 사용해 접근 지시자와 무관하게 값을 설정할 수 있다.
- 리플렉션 시스템을 사용해 언리얼 오브젝트의 함수를 호출할 수 있다.

## 7강 언리얼 C++ 설계1 - 인터페이스

### 인터페이스란?

- 객체가 반드시 구현해야 할 행동을 지정하는데 활용되는 타입
- 다형성의 구현, 의존성이 분리된 설계에 유용하게 활용.

### 언리얼 엔진에서 게임 콘텐츠를 구성하는 오브젝트의 설계 예시

- 월드에 배치되는 모든 오브젝트, 안 움직이는 오브젝트를 포함 (Actor)
- 움직이는 오브젝트 (Pawn)
- 길찾기 시스템을 반드시 사용하면서 움직이는 오브젝트
- (INavAgentInterface 인터페이스를 구현한 Pawn)

### 언리얼 C++ 인터페이스 특징

- 인터페이스를 생성하면 두 개의 클래스가 생성됨
  - U로 시작하는 타입 클래스
  - I로 시작하는 인터페이스 클래스
- 객체를 설계할 때 I 인터페이스 클래스를 사용
  - U타입 클래스 정보는 런타임에서 인터페이스 구현 여부를 파악하는 용도로 사용됨.
  - 실제로 U타입 클래스에서 작업할 일은 없음.
  - 인터페이스에 관련된 구성 및 구현은 I 인터페이스 클래스에서 진행
- C++ 인터페이스의 특징
  - 추상 타입으로만 선언할 수 있는 JAVA, C#과 달리 언리얼은 인터페이스에도 구현이 가능함.

### 정리

- 클래스가 반드시 구현해야 하는 기능을 지정하는데 사용함.
- C++은 기본적으로 다중상속을 지원하지만, 언리얼 C++의 인터페이스를 사용해 가급적 축소된 다중상속의 형태로 구현하는 것이 향후 유지보수에 도움된다.
- 언리얼 C++ 인터페이스는 두 개의 클래스를 생성한다.
- 언리얼 C++ 인터페이스는 추상 타입으로 강제되지 않고, 내부에 기본 함수를 구현할 수 있다.

## 8강 언리얼 C++ 설계2 - 컴포지션

### 컴포지션

- 객체 지향 설계에서 상속이 가진 Is-A관계만 의존해서는 설계와 유지보수가 어려움.
- 컴포지션은 객체 지향 설계에서 Has-A관계를 구현하는 설계 방법
- 컴포지션의 활용
  - 복합적인 기능을 거대한 클래스를 효과적으로 설계하는데 유용하게 사용할 수 있음

### 언리얼 엔지에서의 컴포지션 구현 방법

- 하나의 언리얼 오브젝트에는 항상 클래스 기본 오브젝트 CDO가 있다.
- 언리얼 오브젝트간의 컴포지션은 어떻게 구현할 것인가?
- 언리얼 오브젝트에 다른 언리얼 오브젝트를 조합할 때의 다음의 선택지가 존재한다.
  - 방법 1: CDO에 미리 언리얼 오브젝트를 생성해 조합한다. (필수적 포함)
  - 방법 2: CDO에 빈 포인터만 넣고 런타임에서 언리얼 오브젝트를 생성해 조합한다. (선택적 포함)
- 언리얼 오브젝트를 생성할 때 컴포지션 정보를 구축할 수 있다.
  - 내가 소유한 언리얼 오브젝트를 Subobject라고 한다.
  - 나를 소유한 언리얼 오브젝트를 Outer라고 한다.

### 정리

- 언리얼 C++은 컴포지션을 구현하는 독특한 패턴이 있다.
- 클래스 기본 객체를 생성하는 생성자 코드를 사용해 복잡한 언리얼 오브젝트를 생성할 수 있음.
- 언리얼 C++ 컴포지션의 Has-A관계에 사용되는 용어
  - 내가 소유한 하위 오브젝트 Subobject
  - 나를 소유한 상위 오브젝트: Outer
- 언리얼 C++이 제공하는 확장 열거형을 사용해 다양한 메타 정보를 넣고 활용할 수 있다.

## 9강 언리얼 C++ 설계3 - 델리게이트

### 강한 결합과 느슨한 결합

- 강한 결합
  - 클래스들이 서로 의존성을 가지는 경우를 의미한다.
  - 아래 예시에서 Card가 없는 경우 Person이 만들어질 수 없다.
  - 이때 Person은 Card에 대한 의존성을 가진다고 한다.
  - 핸드폰에서도 인증할 수 있는 새로운 카드가 도입된다면
- 느슨한 결홥
  - 실물에 의존하지 말고 추상적 설계에 의존하라.(DIP 원칙)
  - 왜 Person은 Card가 필요한가? 출입을 확인해야 하기 떄문
  - 출입에 관련된 추상적인 설계에 의존하자.
  - ICheck를 상속받은 새로운 카드 인터페이스를 선언해 해결
  - 이러한 느슨한 결합 구조는 유지 보수를 손쉽게 만들어줌.

### 느슨한 결합의 간편한 구현 - 델리게이트

- 함수를 다루는 방법
  - 함수 포인터를 활용한 콜백함수의 구현
  - 기능은 하나 이를 정의하고 사용하는 과정이 꽤나 복잡함.
  - 안정성을 스스로 검증해주어야 함.
  - C++ 17규약의 std::bind와 std::function 활용은 느림
- C#의 델리게이트 키워드
  - 함수를 마치 객체처럼 다룰 수 있음
  - 안정적이고 간편한 선언
- 언리얼 C++도 델리게이트 지원
  - 느슨한 결합 구조를 간편하고 안정적으로 구현할 수 있음.

### 발행 구독 디자인 패턴

- 푸시 형태의 알림을 구현하는데 적합한 디자인 패턴
- 발행자와 구독자로 구분된다
  - 콘텐츠 제작자는 콘텐츠를 생산한다.
  - 발행자는 콘텐츠를 배포한다.
  - 구독자는 배포된 콘텐츠를 받아 소비한다.
  - 제작자와 구독자가 서로를 몰라도, 발행자를 통해 콘텐츠를 생산하고 전달할 수 있다. (느슨한 결합)
- 발행 구독 디자인 패턴의 장점
  - 제작자와 구독자는 서로를 모르기 떄문에 느슨한 결합으로 구성된다.
  - 유지 보수가 쉽고, 유연하게 활용될 수 있으며, 테스트가 쉬워진다.
  - 시스템 스케일을 유연하게 조절할 수 있으며, 기능 확장이 용이하다.

### 언리얼 델리케이트 선언시 고려사항

- 델리게이트를 설계하기 위한 고려사항

  - 어떤 데이터를 전달하고 받을 것인가? 인자의 수와 각각의 타입을 설계
    - 몇 개의 인자를 전달할 것인가?
    - 어떤 방식으로 전달할 것인가?
    - 일대일로 전달
    - 일대다로 전달
  - 프로그래밍 환경 설정
    - C++ 프로그래밍에서만 사용할 것인가?
    - UFUNCTION으로 지정된 블루프린트 함수와 사용할 것인가?
  - 어떤 함수와 연결할 것인가?
    - 클래스 외부에 설계된 C++ 함수와 연결
    - 전역에 설계된 정적 함수와 연결
    - 언리얼 오브젝트의 맴버 함수와 연결 ( 대부분의 경우에 이 방식을 사용 )

### 언리얼 델리게이트 선언 매크로

**DECLARE\_{델리케이트유형}DELEGATE{함수정보}**

- 델리게이트 유형: 어떤 유형의 델리게이트인지 구상한다
  - 일대일 형태로 C++만 지원한다면 유형은 공란으로 둔다.</br>
    **DECLARE_DELEGATE**
  - 일대다 형태로 C++만 지원한다면 MULTICAST를 선언한다.</br>
    **DECLARE_MULTICAST**
  - 일대일 형태로 블루프린트를 지원한다면 DYNAMIC을 선언한다.</br>
    **DECLARE_DYNAMIC**
  - 일대다 형태로 블루프린트를 지원한다면 DYNAMIC과 MULTICAST를 조합한다.</br>
    **DECLARE_DYNAMIC_MULTICAST**
- 함수 정보 : 연동 될 함수 형태를 지정한다.
  - 인자가 없고 반환값도 없으면 공란으로 둔다.
  - 인자가 하나고 반환값이 없으면 OneParam으로 지정한다.
  - 인자가 세 개고 반환값이 있으면 RetVal_ThreeParams로 지정한다.
  - 최대 9개까지 지원함

### 정리

- 느슨한 결합이 가지는 장점
  - 향후 시스템 변경 사항에 대해 손쉽게 대처할 수 있음
- 느슨한 결합으로 구현된 발행 구독 모델의 장점
  - 클래스는 자신이 해야 할 작업에만 집중할 수 있음.
  - 외부에서 발생한 변경 사항에 대해 영향받지 않음.
  - 자신의 기능을 확장하더라도 다른 모듈에 영향을 주지 않음.
- 언리얼 C++의 델리게이트의 선언 방법과 활용
  - 몇 개의 인자를 가지는가?
  - 어떤 방식으로 동작하는가?
  - 언리얼 에디터와 함께 연동할 것인가?
  - 이를 조합해 적합한 매크로 선택

## 10강 언리얼 컨테이너 라이브러리1 - Array와 Set

### 언리얼 컨테이너 라이브러리

- 언리얼 엔진이 자체 제작해 제공하는 자료구조 라이브러리
- 언리얼 오브젝트를 안정적으로 지원하면 다수 오브젝트 처리에 유용하게 사용됨.
- 언리얼 C++은 다양한 자료구조 라이브러리를 직접 만들어 제공하고 있음.

### C++ STL과 언리얼 컨테이너 라이브러리의 차이점

- C++ STL은 범용적으로 설계되어 있다.
- C++ STL은 표준이기 때문에 호환성이 높다.
- C++ STL에는 많은 기능이 엮여 있어 컴파일 시간이 오래 걸림.
- 언리얼 컨테이너 라이브러리는 언리얼 엔진에 특화되어 있음.
- 언리얼 컨테이너 라이브러리는 언리얼 오브젝트 구조를 안정적으로 지원한다.
- 언리얼 컨테이너 라이브러리는 가볍고 게임 제작에 최적화되어 있음.

### TArray 개요

- TArray는 가변 배열 자료구조
- STL의 vector와 동작 원리가 유사함.
- 게임 제작에서는 가변 배열 자료구조를 효과적으로 활용하는 것이 좋음.
  - 데이터가 순차적으로 모여있기 때문에 메모리를 효과적으로 사용할 수 있고 캐시 효율이 높다.
  - 컴퓨터 사양이 좋아지면서, 캐시 지역성으로 인한 성능 향상은 괴장히 중요해짐.
  - 임의 데이터의 접근이 빠르고, 고속으로 요소를 순회하는 것이 가능.
- 가변 배열의 단점
  - 맨 끝에 데이터를 추가하는 것은 가볍지만, 중간에 요소를 추가하거나 삭제하는 작업은 비용이 큼
  - 데이터가 많아질 수록 검색, 삭제, 수정 작업이 느려지기 때문에, 많은 수의 데이터에서 검색 작업이 빈번하게 일어난다면 TArray대신 TSet을 사용하는 것이 좋음.

### TSet의 특징

- STL의 set과 언리얼 TSet의 비교
  - STL set의 특징
    - STL set은 이진 트리로 구성되어 있어 정렬을 지원함.
    - STL set은 메모리 구성이 효율적이지 않음.
    - STL set은 요소가 삭제될 때 균형을 위한 재구축이 일어날 수 있음.
    - STL set의 모든 자료를 순회하는데 적합하지 않음.
  - 언리얼 TSet 특징
    - TSet은 해시테이블 형태로 키 데이터가 구축되어 있어 빠른 검색이 가능함.
    - TSet은 동적 배열의 형태로 데이터가 모여있음.
    - TSet의 데이터는 빠르게 순회할 수 있음.
    - TSet의 데이터는 삭제해도 재구축이 일어나지 않음.
    - TSet의 자료에는 비어있는 데이터가 있을 수 있음.
- 따라서 STL set과 언리얼 TSet의 활용 방법은 서로 다르기 때문에 주의할 것.
- STL의 unordered_set과 유사하게 동작하지만 동일하진 않음.
- TSet은 중복 없는 데이터 집합을 구축하는데 유용하게 사용할 수 있음.

### 정리

- TArray, TSet 컨테이너 라이브러리 내부 구조와 활용 방법
- 디버그 빌드를 사용해 메모리 정보를 확인하는 방법의 학습
- 두 컨테이너 라이브러리가 가진 특징의 이해
